drop database if exists cook_competition;
create database cook_competition;
use cook_competition;
CREATE TABLE  recipe (
              recipe_id INT NOT NULL AUTO_INCREMENT,
              name VARCHAR(100) NOT NULL,
              difficulty VARCHAR(100) NOT NULL,
              description TEXT,
              tips TEXT,
              is_cooking boolean default TRUE,
              portions INT NOT NULL ,
              basic_ingredient VARCHAR(100) NOT NULL,
              cuisine_id INT NOT NULL ,
              unit_id INT NOT NULL ,
              PRIMARY KEY (recipe_id),
             constraint recipe_ibfk_1 foreign key (cuisine_id) references cuisine(cuisine_id) on delete restrict on update cascade,
            constraint recipe_ibfk_2 foreign key (unit_id) references unit(unit_id) on delete cascade on update cascade

);

CREATE TABLE cuisine (
           cuisine_id INT NOT NULL AUTO_INCREMENT,
           name VARCHAR(100) NOT NULL,
           PRIMARY KEY (cuisine_id)
);

CREATE TABLE meal_type (
             meal_type_id INT NOT NULL AUTO_INCREMENT,
             name VARCHAR(100) NOT NULL,
             PRIMARY KEY (meal_type_id)
);

CREATE TABLE recipe_meal_type (
                recipe_id INT NOT NULL ,
                meal_type_id INT NOT NULL ,
                PRIMARY KEY (recipe_id,meal_type_id),
                constraint recipe_meal_type_ibfk_1 foreign key (recipe_id) references recipe (recipe_id) on delete cascade on update cascade,
                constraint recipe_meal_type_ibfk_2 foreign key (meal_type_id) references meal_type (meal_type_id) on delete cascade on update cascade
);

CREATE TABLE label (
           label_id INT NOT NULL AUTO_INCREMENT,
           name VARCHAR(100) NOT NULL,
           PRIMARY KEY (label_id)
);

CREATE TABLE recipe_label (
           recipe_id INT NOT NULL ,
           label_id INT NOT NULL ,
           PRIMARY KEY (recipe_id,label_id),
           constraint recipe_label_ibfk_1 foreign key (recipe_id) references recipe (recipe_id) on delete cascade on update cascade,
           constraint recipee_label_ibfk_2 foreign key (label_id) references label (label_id) on delete cascade on update cascade
);

CREATE TABLE equipment (
             equipment_id INT NOT NULL AUTO_INCREMENT,
             name VARCHAR(100) NOT NULL,
             description TEXT,
             PRIMARY KEY (equipment_id)
);

CREATE TABLE recipe_equipment (
            recipe_id INT NOT NULL ,
            equipment_id INT NOT NULL ,
            PRIMARY KEY (recipe_id,equipment_id),
            constraint recipe_equipment_ibfk_1 foreign key (recipe_id) references recipe (recipe_id) on delete cascade on update cascade,
            constraint recipe_equipment_ibfk_2 foreign key (equipment_id) references equipment (equipment_id) on delete cascade on update cascade
);


CREATE TABLE step (
            step_id INT NOT NULL AUTO_INCREMENT,
            description VARCHAR(200),
            time INT NOT NULL,
            PRIMARY KEY (step_id)
);

UPDATE step
SET time = SEC_TO_TIME(FLOOR(RAND() * 3600));

CREATE TABLE recipe_step (
               is_prep BOOLEAN DEFAULT FALSE,
               recipe_step_order INT NOT NULL,
               recipe_id INT NOT NULL ,
               step_id INT NOT NULL ,
               PRIMARY KEY (recipe_id,step_id),
               constraint recipe_step_ibfk_1 foreign key (recipe_id) references recipe (recipe_id) on delete cascade on update cascade,
               constraint recipe_step_ibfk_2 foreign key (step_id) references step (step_id) on delete cascade on update cascade
);

CREATE TABLE ingredient (
              ingredient_id INT NOT NULL AUTO_INCREMENT,
              name VARCHAR(100) NOT NULL,
              caloriesper100gr DECIMAL(6,2) NOT NULL ,
              fg_id INT NOT NULL ,
              PRIMARY KEY (ingredient_id),
              constraint ingredient_ibfk_1 foreign key (fg_id) references food_group (fg_id) on delete cascade on update cascade
);


CREATE TABLE recipe_ingredient (
                 quantity DECIMAL(6,2) NOT NULL ,
                 carbon_hydrates DECIMAL(6,2) NOT NULL,
                 protein DECIMAL(6,2) NOT NULL ,
                 fat DECIMAL(6,2) NOT NULL ,
                 recipe_id INT NOT NULL ,
                 ingredient_id INT NOT NULL ,
                 PRIMARY KEY (recipe_id,ingredient_id),
                 constraint recipe_ingredient_ibfk_1 foreign key (recipe_id) references recipe (recipe_id) on delete cascade on update cascade,
                 constraint recipe_ingredient_ibfk_2 foreign key (ingredient_id) references ingredient (ingredient_id) on delete cascade on update cascade
                );

CREATE TABLE food_group (
              fg_id INT NOT NULL AUTO_INCREMENT,
              name VARCHAR(100) NOT NULL,
              description VARCHAR(100),
              PRIMARY KEY (fg_id)
);

CREATE TABLE unit (
            unit_id INT NOT NULL AUTO_INCREMENT,
            name VARCHAR(100) NOT NULL,
            PRIMARY KEY (unit_id)
);

CREATE TABLE topic (
              topic_id INT NOT NULL AUTO_INCREMENT,
              name VARCHAR(300) NOT NULL,
              description VARCHAR(100),
              PRIMARY KEY (topic_id)
);

CREATE TABLE topic_recipe (
             recipe_id INT NOT NULL ,
             topic_id INT NOT NULL ,
             PRIMARY KEY (recipe_id,topic_id),
             constraint topic_recipe_ibfk_1 foreign key (recipe_id) references recipe (recipe_id) on delete cascade on update cascade,
             constraint topic_recipe_ibfk_2 foreign key (topic_id) references topic (topic_id) on delete cascade on update cascade
);

CREATE TABLE cook (
                cook_id INT NOT NULL AUTO_INCREMENT,
                first_name VARCHAR(100) NOT NULL,
                last_name VARCHAR(100) NOT NULL,
                phone_number VARCHAR(15),
                birth_date DATE NOT NULL ,
                age INT NOT NULL,
                grade_id INT NOT NULL ,
                PRIMARY KEY (cook_id),
                constraint cook_ibfk_1 foreign key (grade_id) references grade (grade_id) on delete cascade on update cascade
);

update cook   set age=DATEDIFF(CURRENT_DATE(),birth_date)/365;

CREATE TABLE grade (
             grade_id INT NOT NULL AUTO_INCREMENT,
             name VARCHAR(100) NOT NULL,
             PRIMARY KEY (grade_id)
);

CREATE TABLE cook_specialisation (
               yrs_of_exp INT,
               cuisine_id INT NOT NULL ,
               cook_id INT NOT NULL ,
               PRIMARY KEY (cuisine_id,cook_id),
               constraint cook_specialisation_ibfk_1 foreign key (cuisine_id) references cuisine (cuisine_id) on delete cascade on update cascade,
               constraint cook_specialisation_ibfk_2 foreign key (cook_id) references cook (cook_id) on delete cascade on update cascade
);

CREATE TABLE episode (
               episode_id INT NOT NULL AUTO_INCREMENT,
               calendar_year INT NOT NULL,
               number INT NOT NULL ,
               PRIMARY KEY (episode_id)
);

CREATE TABLE episode_cook (
             episode_id INT NOT NULL ,
             cook_id INT NOT NULL ,
             recipe_id INT NOT NULL ,
             PRIMARY KEY (episode_id,cook_id,recipe_id),
             constraint episode_cook_ibfk_1 foreign key (episode_id) references episode (episode_id) on delete cascade on update cascade,
             constraint episode_cook_ibfk_2 foreign key (cook_id) references cook (cook_id) on delete cascade on update cascade,
             constraint episode_cook_ibfk_3 foreign key (recipe_id) references recipe(recipe_id) on delete cascade on update cascade
);

CREATE TABLE episode_judge (
             episode_id INT NOT NULL ,
             judge_id INT NOT NULL ,
             PRIMARY KEY (episode_id,judge_id),
             constraint episode_judge_ibfk_1 foreign key (episode_id) references episode (episode_id) on delete cascade on update cascade,
             constraint episode_judge_ibfk_2 foreign key (judge_id) references cook (cook_id) on delete cascade on update cascade
);
            


CREATE TABLE score (
             score_id INT NOT NULL AUTO_INCREMENT,
             points INT,
             episode_id INT NOT NULL ,
             cook_id INT NOT NULL,
             judge_id INT NOT NULL ,
             PRIMARY KEY (score_id),
             constraint score_ibfk_1 foreign key (episode_id) references episode (episode_id) on delete cascade on update cascade,
             constraint score_ibfk_2 foreign key (cook_id) references cook(cook_id) on delete cascade on update cascade,
             constraint score_ibfk_3 foreign key (judge_id) references cook(cook_id) on delete cascade on update cascade
             );


DELIMETER //

CREATE PROCEDURE InsertEpisodeCooks(episode_number int, cal_year int)
BEGIN
    if (not exists(Select * from episode where calendar_year=cal_year and number = episode_number)) then
        signal SQLSTATE '45000'
        set message_text = 'There is no such episode - year combination';
    end if;

    if (exists(select * from episode_cook ec inner join episode e on ec.episode_id = e.id
                        where number = episode_number and calendar_year=cal_year)) then
        signal SQLSTATE '45000'
            set message_text = 'There are already cooks selected for this episode';
    end if;

    insert into episode_cook (recipe_id, cook_id, episode_id)
    select  max(recipe_id) as random_recipe_id,
            cook_id as random_cook_id,
            (Select episode.id from episode where calendar_year=cal_year and number = episode_number) as episode_id
    from (select r.id as recipe_id,
                -- Select a random cooks with specialization in each recipe cuisine
                (select cook.id from cook k inner join cook_specialisation cs on k.id = cs.cook_id
                 where r.cuisine_id = cs.cuisine_id
                   -- Each cook should not participate in more than 3 consecutive episodes of the same year
                   and (episode_number < 4  or k.id not in (select cook_id from episode_cook
                                                            inner join episode on episode_cook.episode_id = episode.id
                                                            where number = episode_number-1 and calendar_year = cal_year)
                                            or k.id not in (select cook_id from episode_cook
                                                            inner join episode on episode_cook.episode_id = episode.id
                                                            where number = episode_number-2 and calendar_year = cal_year)
                                            or k.id not in (select cook_id from episode_cook
                                                            inner join episode on episode_cook.episode_id = episode.id
                                                            where number = episode_number-3 and calendar_year = cal_year)
                     )
                 order by rand() limit 1
                ) as cook_id
        -- select 10 random recipes from 10 random cuisines
         from  (select
                -- Select a random recipe for each selected cuisine
                (select recipe_id from recipe where cuisine_id = c1.id order by rand() limit 1) as recipe_id
                from cuisine c1
                -- Each cuisine should not be selected in e consecutive years
                where episode_number < 4
                or id not in (select cuisine_id from recipe
                              inner join episode_cook on recipe.id = episode_cook.recipe_id
                              inner join episode on episode_cook.episode_id = episode.id
                              where number = episode_number-1 and calendar_year = cal_year)
                or id not in (select cuisine_id from recipe
                              inner join episode_cook on recipe.id = episode_cook.recipe_id
                              inner join episode on episode_cook.episode_id = episode.id
                              where number = episode_number-2 and calendar_year = cal_year)
                or id not in (select cuisine_id from recipe
                              inner join episode_cook on recipe.id = episode_cook.recipe_id
                              inner join episode on episode_cook.episode_id = episode.id
                              where number = episode_number-3 and calendar_year = cal_year)
                order by rand() -- randomize the selection by ordering by a random number
               ) rcp inner join recipe r on r.id = rcp.recipe_id
        ) cr
        group by cr.cook_id
        limit 10;
END //

DELIMETER ;







DELIMITER //

CREATE PROCEDURE InsertEpisodeJudges(episode_number INT, cal_year INT)
BEGIN
    DECLARE episodeCount INT;

    -- Check if the episode exists
    SELECT COUNT(*) INTO episodeCount FROM episode WHERE calendar_year = cal_year AND number = episode_number;
    IF episodeCount = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'There is no such episode - year combination';
    END IF;

    -- Check if judges are already selected for this episode
    SELECT COUNT(*) INTO episodeCount FROM episode_judge ej INNER JOIN episode e ON ej.episode_id = e.episode_id
    WHERE e.number = episode_number AND e.calendar_year = cal_year;
    IF episodeCount > 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'There are already judges selected for this episode';
    END IF;

    -- Insert judges for the episode
    INSERT INTO episode_judge (judge_id, episode_id)
    SELECT k.cook_id,
           (SELECT episode_id FROM episode WHERE calendar_year = cal_year AND number = episode_number) AS episode_id
    FROM cook k
    -- Each judge should not participate in more than 3 consecutive episodes of the same year
    WHERE (episode_number < 4 OR k.cook_id NOT IN (
             SELECT judge_id FROM episode_judge ej
             INNER JOIN episode ep ON ej.episode_id = ep.episode_id
             WHERE ep.number IN (episode_number - 1, episode_number - 2, episode_number - 3)
             AND ep.calendar_year = cal_year
         ))
         AND (k.cook_id NOT IN (
             SELECT judge_id FROM episode_judge ej
             INNER JOIN episode ep ON ej.episode_id = ep.episode_id
             WHERE ep.number = episode_number AND ep.calendar_year = cal_year
         ))
    ORDER BY RAND() LIMIT 3;
END //
DELIMITER ;



DELIMITER //

CREATE PROCEDURE Create_Score(IN cook_id INT, IN judge_id INT, IN episode_id INT, IN points INT)
BEGIN
    -- Check if the episode exists
    IF NOT EXISTS (SELECT 1 FROM episode e WHERE e.episode_id = episode_id) THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'There is no such episode';
    END IF;

    -- Check if the cook exists and is assigned to the episode
    IF NOT EXISTS (SELECT 1 FROM episode_cook ec WHERE ec.cook_id = cook_id AND ec.episode_id = episode_id) THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'There is no such cook in this episode';
    END IF;

    -- Check if the judge exists and is assigned to the episode
    IF NOT EXISTS (SELECT 1 FROM episode_judge ej WHERE ej.judge_id = judge_id AND ej.episode_id = episode_id) THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'There is no such judge in this episode';
    END IF;

    -- Check if there is already a score for this cook by this judge for this episode
    IF EXISTS (
        SELECT 1 
        FROM score sc
        WHERE sc.episode_id = episode_id 
          AND sc.cook_id = cook_id 
          AND sc.judge_id = judge_id
    ) THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'There is already a score for this cook by this judge for this episode';
    END IF;

    -- Insert the score into the score table
    INSERT INTO score (points, episode_id, cook_id, judge_id)
    VALUES (points, episode_id, cook_id, judge_id);

END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE Get_Episode_Winner(IN episode_id_val INT)
BEGIN
    DECLARE max_points INT;
    DECLARE highest_grade INT;

    -- Step 1: Find the maximum points received by any cook in the given episode
    SELECT MAX(total_points) INTO max_points
    FROM (
        SELECT SUM(points) AS total_points
        FROM score
        WHERE episode_id = episode_id_val
        GROUP BY cook_id
    ) AS cook_totals;

    -- Step 2: Identify cooks with the maximum points
    CREATE TEMPORARY TABLE Temp_Max_Points_Cooks AS
    SELECT c.cook_id, c.first_name, c.last_name, c.grade_id, SUM(s.points) AS total_points
    FROM cook c
    JOIN score s ON c.cook_id = s.cook_id
    WHERE s.episode_id = episode_id_val
    GROUP BY c.cook_id;

    -- Step 3: If more than one cook has the maximum points, find the highest grade among them
    SELECT MAX(grade_id) INTO highest_grade
    FROM Temp_Max_Points_Cooks;

    -- Step 4: Identify cooks with the highest grade among those with maximum points
    CREATE TEMPORARY TABLE Temp_Highest_Grade_Cooks AS
    SELECT * 
    FROM Temp_Max_Points_Cooks
    WHERE total_points = max_points;

    -- Step 5: If more than one cook has the highest grade, select a random cook among them
    IF (SELECT COUNT(*) FROM Temp_Highest_Grade_Cooks) > 1 THEN
        SELECT cook_id, first_name, last_name, total_points, grade_id
        FROM Temp_Highest_Grade_Cooks
        ORDER BY RAND()
        LIMIT 1;
    ELSE
        -- If there is only one cook with the highest grade, that cook is the winner
        SELECT cook_id, first_name, last_name, total_points, grade_id
        FROM Temp_Highest_Grade_Cooks;
    END IF;

    -- Clean up temporary tables
    DROP TEMPORARY TABLE IF EXISTS Temp_Max_Points_Cooks;
    DROP TEMPORARY TABLE IF EXISTS Temp_Highest_Grade_Cooks;

END //

DELIMITER ;


DELIMITER //
CREATE PROCEDURE Create_Cook_Random_Scores()
BEGIN
    INSERT INTO score (points, episode_id, cook_id, judge_id)
    SELECT FLOOR(RAND() * 5) + 1, ec.episode_id, ec.cook_id, ej.judge_id
    FROM episode_cook ec
    INNER JOIN episode_judge ej ON ec.episode_id = ej.episode_id;
END //

DELIMITER ;


